<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberChat '95 - Encrypted Messenger</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "MS Sans Serif", Arial, sans-serif;
            font-size: 11px;
            background: #008080;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            image-rendering: pixelated;
        }

        .container {
            position: fixed;
            width: 640px;
            height: 480px;
            background: #C0C0C0;
            border: 2px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
            display: flex;
            flex-direction: column;
            box-shadow: 1px 1px 0 #000000;
            left: calc(50% - 320px);
            top: calc(50% - 240px);
            z-index: 1000;
        }

        .container.dragging {
            cursor: move;
        }

        /* Title Bar */
        .title-bar {
            background: linear-gradient(to right, #000080, #1084D0);
            color: white;
            padding: 2px 4px;
            font-weight: bold;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            user-select: none;
        }

        .title-bar button {
            width: 16px;
            height: 14px;
            background: #C0C0C0;
            border: 2px solid;
            border-color: #FFFFFF #000000 #000000 #FFFFFF;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
        }

        /* Landing Page */
        .landing {
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            height: 100%;
            background: #C0C0C0;
        }

        .window-content {
            border: 2px solid;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            background: #C0C0C0;
            padding: 20px;
            margin: 10px;
        }

        .landing h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #000080;
            text-shadow: 1px 1px 0 #FFFFFF;
            font-family: "Times New Roman", serif;
        }

        .landing p {
            color: #000000;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 4px;
            font-weight: bold;
        }

        .form-group input {
            width: 100%;
            padding: 2px 4px;
            border: 2px solid;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            background: #FFFFFF;
            font-family: "MS Sans Serif", Arial, sans-serif;
            font-size: 11px;
        }

        .button {
            background: #C0C0C0;
            border: 2px solid;
            border-color: #FFFFFF #000000 #000000 #FFFFFF;
            padding: 4px 16px;
            font-family: "MS Sans Serif", Arial, sans-serif;
            font-size: 11px;
            cursor: pointer;
            min-width: 75px;
        }

        .button:active {
            border-color: #000000 #FFFFFF #FFFFFF #000000;
        }

        .button:focus {
            outline: 1px dotted #000000;
            outline-offset: -4px;
        }

        .share-link {
            margin-top: 15px;
            padding: 8px;
            background: #FFFFFF;
            border: 2px solid;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            font-family: "Courier New", monospace;
            font-size: 10px;
            word-break: break-all;
        }

        /* Chat Interface */
        .chat {
            display: none;
            flex-direction: column;
            height: 100%;
            background: #C0C0C0;
        }

        .chat-header {
            background: #C0C0C0;
            padding: 8px;
            border-bottom: 2px solid;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .connection-status {
            font-size: 10px;
            padding: 1px 4px;
            border: 1px solid #000000;
        }

        .connection-status.connected {
            background: #00FF00;
            color: #000000;
        }

        .connection-status.disconnected {
            background: #FF0000;
            color: #FFFFFF;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            background: #FFFFFF;
            border: 2px solid;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            margin: 8px;
            font-family: "Courier New", monospace;
            font-size: 12px;
        }

        .message {
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .message-header {
            color: #0000FF;
            font-weight: bold;
        }

        .message.own .message-header {
            color: #FF0000;
        }

        .message-content {
            color: #000000;
            margin-left: 20px;
        }

        .message-time {
            color: #808080;
            font-size: 10px;
        }

        .key-input {
            padding: 8px;
            margin: 0 8px;
            background: #FFFFE0;
            border: 2px solid;
            border-color: #000000 #FFFFFF #FFFFFF #000000;
            text-align: center;
        }

        .chat-input {
            padding: 8px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .chat-input input {
            flex: 1;
            padding: 2px 4px;
            border: 2px solid;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            background: #FFFFFF;
            font-family: "MS Sans Serif", Arial, sans-serif;
            font-size: 11px;
        }

        .system-message {
            text-align: center;
            color: #008000;
            font-style: italic;
            margin: 8px 0;
        }

        .ascii-art {
            font-family: "Courier New", monospace;
            font-size: 10px;
            line-height: 1;
            color: #000080;
            white-space: pre;
            margin: 10px 0;
        }

        /* Scrollbar styling for that 90s look */
        ::-webkit-scrollbar {
            width: 16px;
        }

        ::-webkit-scrollbar-track {
            background: #C0C0C0;
            border: 1px solid;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
        }

        ::-webkit-scrollbar-thumb {
            background: #C0C0C0;
            border: 2px solid;
            border-color: #FFFFFF #000000 #000000 #FFFFFF;
        }

        /* Smaller window on mobile */
        @media (max-width: 768px) {
            .container {
                width: 90vw;
                max-width: 480px;
                height: 70vh;
                max-height: 400px;
                left: 5vw;
                top: 15vh;
            }
            
            .chess-window {
                width: 90vw;
                max-width: 360px;
                height: 420px;
                left: 5vw;
                top: 5vh;
            }
            
            .chess-board {
                width: 280px;
                height: 280px;
                grid-template-columns: repeat(8, 35px);
                grid-template-rows: repeat(8, 35px);
            }
            
            .chess-square {
                width: 35px;
                height: 35px;
                font-size: 24px;
            }
        }

        /* Chess Window */
        .chess-window {
            position: fixed;
            width: 400px;
            height: 460px;
            background: #C0C0C0;
            border: 2px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
            display: none;
            flex-direction: column;
            box-shadow: 1px 1px 0 #000000;
            left: 100px;
            top: 100px;
            z-index: 1001;
        }

        .chess-window.dragging {
            cursor: move;
        }

        .chess-board {
            width: 320px;
            height: 320px;
            margin: 20px auto;
            border: 2px solid;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            display: grid;
            grid-template-columns: repeat(8, 40px);
            grid-template-rows: repeat(8, 40px);
            background: #FFFFFF;
        }

        .chess-square {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            user-select: none;
        }

        .chess-square.light {
            background: #F0D9B5;
        }

        .chess-square.dark {
            background: #B58863;
        }

        .chess-square.highlight {
            background: #FFFF00 !important;
        }

        .chess-piece {
            cursor: grab;
            transition: none;
        }

        .chess-piece.dragging {
            cursor: grabbing;
            opacity: 0.5;
        }

        .chess-controls {
            padding: 8px;
            text-align: center;
        }

        .show-chess {
            margin-left: 10px;
            padding: 2px 8px !important;
            font-size: 10px !important;
            min-width: 50px !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title-bar">
            <span>CyberChat '95 - Encrypted Messenger</span>
            <button onclick="alert('Welcome to the 90s!')">X</button>
        </div>

        <!-- Landing Page -->
        <div id="landing" class="landing">
            <div class="window-content">
                <h1>Welcome to CyberChat '95</h1>
                <div class="ascii-art">
╔═══════════════════════════════╗
║  SECURE * PRIVATE * ENCRYPTED ║
╚═══════════════════════════════╝</div>
                <p>Create a secure chatroom for up to 4 people. All messages are encrypted with your shared secret key!</p>
                
                <div class="form-group">
                    <label for="username">Choose Your Handle:</label>
                    <input type="text" id="username" placeholder="CyberWarrior" maxlength="20">
                </div>
                
                <button class="button" onclick="createRoom()">Create New Room</button>
                
                <div id="roomLink" style="display:none;">
                    <p style="margin-top: 15px;"><strong>Share this link with your friends:</strong></p>
                    <div class="share-link" id="shareLink"></div>
                    <div style="margin-top: 10px;">
                        <button class="button" onclick="copyLink()">Copy Link</button>
                        <button class="button" onclick="enterRoom()">Enter Room</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat Interface -->
        <div id="chat" class="chat">
            <div class="chat-header">
                <div class="user-info">
                    <strong>Room: <span id="roomName"></span></strong>
                    <span class="connection-status disconnected" id="connectionStatus">OFFLINE</span>
                    <button class="button show-chess" onclick="toggleChess()">♟ Chess</button>
                </div>
                <span id="userCount">1 user online</span>
            </div>
            
            <div class="key-input" id="keyInput">
                <strong>ENCRYPTION REQUIRED:</strong> Enter your shared secret key:
                <input type="password" id="encryptionKey" placeholder="Secret key" style="margin: 0 8px;">
                <button class="button" onclick="setKey()">Set Key</button>
                <div style="color: red; margin-top: 4px;" id="keyError"></div>
            </div>

            <div class="messages" id="messages">
                <div class="system-message">*** Welcome to CyberChat '95! Set your encryption key to start chatting. ***</div>
            </div>

            <div class="chat-input">
                <input type="text" id="messageInput" placeholder="Type your message here..." disabled>
                <button class="button" onclick="sendMessage()" id="sendButton" disabled>Send</button>
            </div>
        </div>

        <!-- Chess Window -->
        <div id="chessWindow" class="chess-window">
            <div class="title-bar" id="chessTitleBar">
                <span>Chess Board - Room: <span id="chessRoomName"></span></span>
                <button onclick="toggleChess()">X</button>
            </div>
            <div class="chess-board" id="chessBoard"></div>
            <div class="chess-controls">
                <button class="button" onclick="resetChessBoard()">New Game</button>
                <span style="margin-left: 10px;" id="chessStatus">White to move</span>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let roomId = null;
        let userId = null;
        let username = null;
        let encryptionKey = null;
        let messages = [];
        let ws = null;
        let reconnectInterval = null;
        let isConnected = false;

        // Create a more pleasant notification sound (lower pitched bell)
        const messageSound = new Audio('data:audio/wav;base64,UklGRiQFAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAFAACAhYSFh4WFh4aIiYaGh4aFh4WGgwAAAAAAAAAAAAAAAAAAAAB1b2VqaW5sbmxtbm1sa2pqaWprbG1ub25ub25ub29ub25vb3BvcHFwcHJxcnJzcnNzdHR0dHR1dXZ1dXZ2dnd3eHd5eHh5eXp5eXp7e3x7e3x9fn19fn5/f4CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAgICAgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAgICBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYCAhYKDg4KDg4SEhYWFhISDg4KDgIB8e3d3dHRzdHR1dXZ2dnh3eXl5ent7fH19fn+AgYCBgYCBgIGAf359fHx7e3p5eXh4d3d2dXV0c3NycnBxcG9ubm1tbGxqamppaWlpZ2hoZ2dmZ2ZmZWVlZGRkY2RjY2JhYmJgYV9fX19fXl5fXl9dXV1dXF1bXFxbW1pbWlpaWVlZWFlYWVlYV1hYV1hXV1dWVldWVlZVVlVVVVVVVFVUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFNTVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFVVVVVWVldWV1hXWFhYWFlaWVpbW1xbXFxdXV5eX19gYGFhYWJjY2RkZGVmZ2doaGhpa2pra21tbm5vcHFxcXJzdHV1dnd4d3h5enp7fH1+foCAgIGCg4SEhYaGh4iIiYqKi4uMjY2Njo6OjpCOj4+QkJCRkZGSkpOSk5OTlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSTk5STk5OTk5OTk5OTk5OSkpKTk5KSkpKSkpKSkpKSkpKSkpGRkZGRkZGRkZGQkZGQkJGQkZCRkJGQkJCQkJCQkJCQkJCQkJCQj5CQj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pjo+Pj46Ojo6Ojo2Ojo6Ojo6Ojo6OjY6Njo2OjY2Njo2OjY6Njo2OjY6Njo2OjY6Njo6Ojo6Oj46Pj5CPj5CPkJCPj5CQkJCQkJCQkJCQkJCQkJCQkJCQkJGRkZGRkZGRkZGRkZKRkpKSkpKSk5KTkpKTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OUk5OTk5STk5OTk5OTk5OTk5OTk5OUk5SUlJSTlJOUlJOUk5STlJOUk5SUk5SUk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5STlJOUk5STlJOUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJQ=');

        // Check if joining existing room
        const urlParams = new URLSearchParams(window.location.search);
        const joinRoomId = urlParams.get('room');
        if (joinRoomId) {
            // Prompt for username first
            document.getElementById('roomLink').style.display = 'none';
        }

        // Create new room
        function createRoom() {
            const usernameInput = document.getElementById('username');
            username = usernameInput.value.trim() || 'Anonymous' + Math.floor(Math.random() * 1000);
            
            roomId = generateRoomId();
            userId = generateUserId();
            
            const roomLink = `${window.location.origin}${window.location.pathname}?room=${roomId}`;
            document.getElementById('shareLink').textContent = roomLink;
            document.getElementById('roomLink').style.display = 'block';
        }

        // Enter room button
        function enterRoom() {
            if (roomId) {
                joinRoom(roomId);
            }
        }

        // Join existing room
        function joinRoom(id) {
            // Get username if not set
            if (!username) {
                const usernameInput = document.getElementById('username');
                username = usernameInput.value.trim() || 'Anonymous' + Math.floor(Math.random() * 1000);
            }
            
            roomId = id;
            userId = generateUserId();
            
            document.getElementById('landing').style.display = 'none';
            document.getElementById('chat').style.display = 'flex';
            document.getElementById('roomName').textContent = roomId.toUpperCase();
            
            // Connect to WebSocket
            connectWebSocket();
        }

        // WebSocket connection
        function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) return;
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}`;
            
            console.log('Connecting to WebSocket:', wsUrl);
            
            try {
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    console.log('Connected to server');
                    isConnected = true;
                    updateConnectionStatus(true);
                    
                    // Clear reconnect interval
                    if (reconnectInterval) {
                        clearInterval(reconnectInterval);
                        reconnectInterval = null;
                    }
                    
                    // Join room with username
                    if (roomId && userId) {
                        ws.send(JSON.stringify({
                            type: 'join',
                            roomId: roomId,
                            userId: userId,
                            username: username
                        }));
                    }
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    
                    switch (data.type) {
                        case 'joined':
                            userId = data.userId;
                            addSystemMessage(`*** ${username} has entered the chat room ***`);
                            break;
                            
                        case 'messages':
                            // Display existing messages
                            data.messages.forEach(msg => {
                                if (!messages.find(m => m.id === msg.id)) {
                                    messages.push(msg);
                                    displayMessage(msg);
                                }
                            });
                            break;
                            
                        case 'message':
                            // New message from another user - only show if not from self
                            if (data.message.userId !== userId) {
                                messages.push(data.message);
                                displayMessage(data.message);
                                // Play sound for new messages
                                if (encryptionKey) {
                                    messageSound.play().catch(e => console.log('Sound play failed:', e));
                                }
                            }
                            break;
                            
                        case 'user_count':
                            updateUserCount(data.count);
                            break;
                            
                        case 'user_joined':
                            if (data.username !== username) {
                                addSystemMessage(`*** ${data.username} has entered the chat room ***`);
                            }
                            break;
                            
                        case 'user_left':
                            addSystemMessage(`*** ${data.username} has left the chat room ***`);
                            break;
                            
                        case 'chess_move':
                            // Update chess board from another player's move
                            if (data.board) {
                                chessBoard = data.board;
                                currentTurn = data.turn;
                                document.getElementById('chessStatus').textContent = currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1) + ' to move';
                                initChessBoard();
                                addSystemMessage(`*** Chess move: ${data.username} moved a piece ***`);
                            }
                            break;
                            
                        case 'chess_reset':
                            // Reset chess board
                            chessBoard = JSON.parse(JSON.stringify(initialBoard));
                            currentTurn = 'white';
                            document.getElementById('chessStatus').textContent = 'White to move';
                            initChessBoard();
                            addSystemMessage(`*** ${data.username} started a new chess game ***`);
                            break;
                            
                        case 'chess_state':
                            // Sync chess state for new users
                            if (data.board) {
                                chessBoard = data.board;
                                currentTurn = data.turn;
                                document.getElementById('chessStatus').textContent = currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1) + ' to move';
                                if (document.getElementById('chessWindow').style.display !== 'none') {
                                    initChessBoard();
                                }
                            }
                            break;
                            
                        case 'error':
                            alert(data.message);
                            window.location.href = '/';
                            break;
                    }
                };
                
                ws.onclose = () => {
                    console.log('Disconnected from server');
                    isConnected = false;
                    updateConnectionStatus(false);
                    
                    // Try to reconnect every 3 seconds
                    if (!reconnectInterval) {
                        reconnectInterval = setInterval(() => {
                            console.log('Attempting to reconnect...');
                            connectWebSocket();
                        }, 3000);
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    isConnected = false;
                    updateConnectionStatus(false);
                };
                
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                isConnected = false;
                updateConnectionStatus(false);
            }
        }

        // Update connection status display
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connectionStatus');
            if (connected) {
                statusEl.textContent = 'ONLINE';
                statusEl.className = 'connection-status connected';
            } else {
                statusEl.textContent = 'OFFLINE';
                statusEl.className = 'connection-status disconnected';
            }
        }

        // Set encryption key
        function setKey() {
            const keyInput = document.getElementById('encryptionKey');
            const key = keyInput.value.trim();
            
            if (!key) {
                document.getElementById('keyError').textContent = 'ERROR: Key required!';
                return;
            }
            
            encryptionKey = key;
            document.getElementById('keyInput').style.display = 'none';
            document.getElementById('messageInput').disabled = false;
            document.getElementById('sendButton').disabled = false;
            document.getElementById('messageInput').focus();
            
            addSystemMessage('*** Encryption key set. Secure channel established. ***');
        }

        // Send message
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message || !encryptionKey) return;
            
            if (!isConnected || !ws || ws.readyState !== WebSocket.OPEN) {
                alert('ERROR: Not connected to server. Please wait for connection.');
                return;
            }
            
            const encrypted = await encryptMessage(message, encryptionKey);
            
            const messageObj = {
                id: Date.now(),
                userId: userId,
                username: username,
                encrypted: encrypted,
                timestamp: new Date()
            };
            
            // Send via WebSocket
            ws.send(JSON.stringify({
                type: 'message',
                encrypted: encrypted,
                username: username
            }));
            
            // Add to local messages and display immediately
            messages.push(messageObj);
            displayMessage(messageObj, message);
            
            // Clear input
            input.value = '';
        }

        // Display message
        function displayMessage(messageObj, decryptedText = null) {
            const messagesEl = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = `message ${messageObj.userId === userId ? 'own' : ''}`;
            
            const time = new Date(messageObj.timestamp).toLocaleTimeString([], { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            const displayName = messageObj.username || `User${messageObj.userId.substr(0,4)}`;
            
            if (decryptedText) {
                messageEl.innerHTML = `
                    <div class="message-header">&lt;${escapeHtml(displayName)}&gt; <span class="message-time">[${time}]</span></div>
                    <div class="message-content">${escapeHtml(decryptedText)}</div>
                `;
            } else {
                // Try to decrypt
                if (encryptionKey) {
                    decryptMessage(messageObj.encrypted, encryptionKey).then(text => {
                        messageEl.innerHTML = `
                            <div class="message-header">&lt;${escapeHtml(displayName)}&gt; <span class="message-time">[${time}]</span></div>
                            <div class="message-content">${escapeHtml(text)}</div>
                        `;
                    }).catch(() => {
                        messageEl.innerHTML = `
                            <div class="message-header">&lt;${escapeHtml(displayName)}&gt; <span class="message-time">[${time}]</span></div>
                            <div class="message-content" style="color: #FF0000;">[DECRYPTION ERROR - INVALID KEY]</div>
                        `;
                    });
                } else {
                    messageEl.innerHTML = `
                        <div class="message-header">&lt;${escapeHtml(displayName)}&gt; <span class="message-time">[${time}]</span></div>
                        <div class="message-content" style="color: #808080;">[ENCRYPTED MESSAGE - KEY REQUIRED]</div>
                    `;
                }
            }
            
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        // Encryption functions
        async function encryptMessage(message, key) {
            const encoder = new TextEncoder();
            const data = encoder.encode(message);
            
            const keyMaterial = await getKeyMaterial(key);
            const cryptoKey = await window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: encoder.encode("static-salt"), // Use static salt for simplicity
                    iterations: 100000,
                    hash: "SHA-256"
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
            
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await window.crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                cryptoKey,
                data
            );
            
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv);
            combined.set(new Uint8Array(encrypted), iv.length);
            
            return btoa(String.fromCharCode(...combined));
        }

        async function decryptMessage(encryptedBase64, key) {
            try {
                const encoder = new TextEncoder();
                const combined = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
                
                const iv = combined.slice(0, 12);
                const encrypted = combined.slice(12);
                
                const keyMaterial = await getKeyMaterial(key);
                const cryptoKey = await window.crypto.subtle.deriveKey(
                    {
                        name: "PBKDF2",
                        salt: encoder.encode("static-salt"),
                        iterations: 100000,
                        hash: "SHA-256"
                    },
                    keyMaterial,
                    { name: "AES-GCM", length: 256 },
                    false,
                    ["encrypt", "decrypt"]
                );
                
                const decrypted = await window.crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    cryptoKey,
                    encrypted
                );
                
                return new TextDecoder().decode(decrypted);
            } catch (error) {
                throw new Error('Decryption failed');
            }
        }

        async function getKeyMaterial(password) {
            const encoder = new TextEncoder();
            return window.crypto.subtle.importKey(
                "raw",
                encoder.encode(password),
                "PBKDF2",
                false,
                ["deriveBits", "deriveKey"]
            );
        }

        // Helper functions
        function generateRoomId() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        function generateUserId() {
            return Math.random().toString(36).substr(2, 9);
        }

        function updateUserCount(count = 1) {
            document.getElementById('userCount').textContent = `${count} user${count !== 1 ? 's' : ''} online`;
        }

        function addSystemMessage(text) {
            const messagesEl = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'system-message';
            messageEl.textContent = text;
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function copyLink() {
            const link = document.getElementById('shareLink').textContent;
            navigator.clipboard.writeText(link);
            alert('Link copied to clipboard!');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Enter key to send
        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        document.getElementById('encryptionKey').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                setKey();
            }
        });

        // Auto-join if room in URL
        if (joinRoomId) {
            window.addEventListener('load', () => {
                setTimeout(() => {
                    const usernamePrompt = prompt('Enter your username:', 'User' + Math.floor(Math.random() * 1000));
                    if (usernamePrompt) {
                        username = usernamePrompt.trim().substr(0, 20);
                        joinRoom(joinRoomId);
                    }
                }, 100);
            });
        }

        // Make windows draggable
        let zIndex = 1001;
        
        function makeDraggable(windowElement, titleBarElement) {
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;

            // Bring window to front when clicked
            windowElement.addEventListener('mousedown', () => {
                windowElement.style.zIndex = ++zIndex;
            });

            // Mouse events
            titleBarElement.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            // Touch events for mobile
            titleBarElement.addEventListener('touchstart', dragStart, {passive: false});
            document.addEventListener('touchmove', drag, {passive: false});
            document.addEventListener('touchend', dragEnd);

            function dragStart(e) {
                if (e.target.tagName === 'BUTTON') return;
                
                const rect = windowElement.getBoundingClientRect();
                
                if (e.type === 'touchstart') {
                    initialX = e.touches[0].clientX - rect.left;
                    initialY = e.touches[0].clientY - rect.top;
                } else {
                    initialX = e.clientX - rect.left;
                    initialY = e.clientY - rect.top;
                }

                if (e.target === titleBarElement || titleBarElement.contains(e.target)) {
                    isDragging = true;
                    windowElement.classList.add('dragging');
                }
            }

            function drag(e) {
                if (e.preventDefault) {
                    e.preventDefault();
                }

                if (isDragging) {
                    if (e.type === 'touchmove') {
                        currentX = e.touches[0].clientX - initialX;
                        currentY = e.touches[0].clientY - initialY;
                    } else {
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                    }

                    const maxX = window.innerWidth - windowElement.offsetWidth;
                    const maxY = window.innerHeight - windowElement.offsetHeight;
                    
                    currentX = Math.max(0, Math.min(currentX, maxX));
                    currentY = Math.max(0, Math.min(currentY, maxY));

                    windowElement.style.left = currentX + 'px';
                    windowElement.style.top = currentY + 'px';
                }
            }

            function dragEnd(e) {
                isDragging = false;
                windowElement.classList.remove('dragging');
            }
        }

        // Make chat window draggable
        const container = document.querySelector('.container');
        const titleBar = document.querySelector('.title-bar');
        makeDraggable(container, titleBar);

        // Make chess window draggable
        const chessWindow = document.getElementById('chessWindow');
        const chessTitleBar = document.getElementById('chessTitleBar');
        makeDraggable(chessWindow, chessTitleBar);

        // Chess functionality
        const chessPieces = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        const initialBoard = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        let chessBoard = JSON.parse(JSON.stringify(initialBoard));
        let currentTurn = 'white';
        let draggedPiece = null;
        let draggedFrom = null;

        function initChessBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'chess-square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    const piece = chessBoard[row][col];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = 'chess-piece';
                        pieceElement.textContent = chessPieces[piece];
                        pieceElement.draggable = true;
                        pieceElement.addEventListener('dragstart', handleDragStart);
                        pieceElement.addEventListener('dragend', handleDragEnd);
                        square.appendChild(pieceElement);
                    }
                    
                    square.addEventListener('dragover', handleDragOver);
                    square.addEventListener('drop', handleDrop);
                    
                    boardElement.appendChild(square);
                }
            }
        }

        function handleDragStart(e) {
            const square = e.target.parentElement;
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);
            const piece = chessBoard[row][col];
            
            // Check if it's the correct player's turn
            const isWhitePiece = piece === piece.toUpperCase();
            if ((currentTurn === 'white' && !isWhitePiece) || (currentTurn === 'black' && isWhitePiece)) {
                e.preventDefault();
                return;
            }
            
            draggedPiece = piece;
            draggedFrom = { row, col };
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDrop(e) {
            e.preventDefault();
            if (!draggedPiece || !draggedFrom) return;
            
            const toRow = parseInt(e.currentTarget.dataset.row);
            const toCol = parseInt(e.currentTarget.dataset.col);
            
            // Make the move
            makeChessMove(draggedFrom.row, draggedFrom.col, toRow, toCol);
            
            draggedPiece = null;
            draggedFrom = null;
        }

        function makeChessMove(fromRow, fromCol, toRow, toCol) {
            // Basic move validation (can be expanded)
            if (fromRow === toRow && fromCol === toCol) return;
            
            const piece = chessBoard[fromRow][fromCol];
            if (!piece) return;
            
            // Update board
            chessBoard[toRow][toCol] = piece;
            chessBoard[fromRow][fromCol] = null;
            
            // Switch turns
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            document.getElementById('chessStatus').textContent = currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1) + ' to move';
            
            // Update display
            initChessBoard();
            
            // Broadcast move
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'chess_move',
                    from: { row: fromRow, col: fromCol },
                    to: { row: toRow, col: toCol },
                    board: chessBoard,
                    turn: currentTurn,
                    username: username
                }));
            }
        }

        function toggleChess() {
            const chessWindow = document.getElementById('chessWindow');
            if (chessWindow.style.display === 'none' || !chessWindow.style.display) {
                chessWindow.style.display = 'flex';
                document.getElementById('chessRoomName').textContent = roomId ? roomId.toUpperCase() : 'NONE';
                initChessBoard();
            } else {
                chessWindow.style.display = 'none';
            }
        }

        function resetChessBoard() {
            if (confirm('Start a new game? This will reset the board for all players.')) {
                chessBoard = JSON.parse(JSON.stringify(initialBoard));
                currentTurn = 'white';
                document.getElementById('chessStatus').textContent = 'White to move';
                initChessBoard();
                
                // Broadcast reset
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'chess_reset',
                        username: username
                    }));
                }
            }
        }
    </script>
</body>
</html>
